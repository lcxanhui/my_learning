/*****************************************************************************************************
 *         剑指offer第32 题
 * 计算 1 至 n 中数字 1 出现的次数，
 *
 * Input:  数字n
 * Output: 出现1的次数
 *
 * Note:
 * 参考解析 https://leetcode.com/problems/number-of-digit-one/discuss/64381/4-lines-olog-n-cjavapython
       以及 http://www.cnblogs.com/cyjb/p/digitOccurrenceInRegion.html

        m        a        b             ones
		1	    3141592	  0	     (3141592+8)/10*1+0=314160
		10	    314159	  2	     (314159+8)/10*10+0=314160
		100	    31415	  92	 (31415+8)/10*100+0=314200
		1000	3141	  592	 (3141+8)/101000+1(592+1)=314593
下面说下a+8的意义：    以当n = 3141592时为例子:
	当考虑个位，十位，百位这三位为1的情况时：
   个位 2，当个位取值1时，前面的六位数字可由0~314159组成，即314160种情况
   十位 9，当十位取值1时，前面的五位数字可由0~31415组成，十位之后的一位可由0~9组成，组合情况31416*10=314160种情况
   百位 5，当百位取值为1时，前面的四位数字可由0~3141组成，百位之后的两位可由0~99组成，组合情况为3142*100=314200种情况
注意：当考虑千位1时：
	千位1，千位取值即1，前面的三位数字可由0~314组成，但是当前面的值为314时，后面的三位只有0~592种情况(特殊情况)，
	其余的情况即为前面的值为0~313,后面三位有0~999,情况数为3141000，所以总情况数为3141000 + 593=314593种情况
	这时可发现和代码中的公式算的情况是吻合的，a+8的巧妙之处在于当a的最后一位(当前分析位)为0或1时，加8不产生进位，
	这是为需要单独算的特殊情况做准备，而当前分析位为2~9时，不需要考虑特殊情况，所以允许加8产生的进位。
 * author: lcxanhui@163.com
 * time: 2019.5.14
 ******************************************************************************************************/

#include<iostream>
#include<vector>
using namespace std;

int NumOf1(int n)
{
	int ones = 0;
	for (long long m = 1; m <= n; m *= 10)
	{
		int a = n / m, b = n % m;
		ones += (a + 8) / 10*m + (a % 10 == 1)*(b + 1);	
	}
	return ones;
}

int main(void)
{
	int n;
	cin >> n;
	int res = NumOf1(n);
	cout << res;
	return 0;
}